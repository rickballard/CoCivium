param(
  [string]$ConfigPath = (Join-Path (Split-Path $PSCommandPath -Parent) "..\index\coindex.config.json")
)
Set-StrictMode -Version Latest; $ErrorActionPreference='Stop'

function Get-Yfm { param([string]$Text)
  if($Text -match '^\s*---\s*\r?\n(.*?)\r?\n---\s*'){ return $Matches[1] } return $null }
function Get-H1 { param([string]$Text)
  foreach($l in $Text -split "`r?`n"){ if($l -match '^\s*#\s+(.+)$'){ return $Matches[1].Trim() } } return $null }
function Infer-Role { param([string]$Path)
  if($Path -match '(^|/|\\)\.github(/|\\)workflows(/|\\)'){return 'CI workflow'}
  if($Path -match '(^|/|\\)\.github(/|\\)'){return 'GitHub meta'}
  if($Path -match '(^|/|\\)docs(/|\\)'){return 'Doc'}
  if($Path -match '(^|/|\\)scripts(/|\\)'){return 'Script'}
  if($Path -match '(^|/|\\)tools(/|\\)'){return 'Tool'}
  if($Path -match '(^|/|\\)assets(/|\\|$)'){return 'Asset'}
  if($Path -match '(?i)readme\.md$'){return 'README'}
  if($Path -match '(?i)license'){return 'License'}
  if($Path -match '(?i)codeowners'){return 'CODEOWNERS'}
  return 'File'
}
function Is-TextLike { param([string]$Ext,[string[]]$Allow) return ($Allow -contains $Ext.ToLower()) }

if(!(Test-Path $ConfigPath)){ throw "Missing config: $ConfigPath" }
$cfg     = Get-Content $ConfigPath -Raw | ConvertFrom-Json
$repos   = @($cfg.repos) | Where-Object { $_ -and (Test-Path $_) }
$maxHash = [int]$cfg.maxHashBytes
$allow   = @($cfg.includeExtensions)
$exRx    = [regex]$cfg.excludePathRegex
$branch  = [string]$cfg.branchName
$makePR  = [bool]$cfg.makePR

$ts = Get-Date -Format 'yyyyMMdd_HHmmss'
$master = New-Object System.Collections.Generic.List[object]

foreach($root in $repos){
  Push-Location $root
  try{
    $gitRoot = (git rev-parse --show-toplevel 2>$null); if(-not $gitRoot){ continue }
    $repoName = Split-Path $gitRoot -Leaf
    $headSha  = (git rev-parse --short HEAD 2>$null)

    $rows  = New-Object System.Collections.Generic.List[object]
    $links = New-Object System.Collections.Generic.List[object]
    Get-ChildItem $gitRoot -Recurse -File -EA SilentlyContinue | ForEach-Object {
      $f   = $_
      $rel = ($f.FullName.Substring($gitRoot.Length)).TrimStart('\','/')
      if($exRx.IsMatch($rel)){ return }
      $ext  = $f.Extension
      $size = $f.Length
      $sha1 = $null
      if($size -le $maxHash){ $sha1 = (Get-FileHash -Algorithm SHA1 -LiteralPath $f.FullName).Hash.ToLower() }

      $purpose = $null; $text = $null
      if(Is-TextLike $ext $allow){
        $text = Get-Content $f.FullName -Raw -EA SilentlyContinue
        $fm   = Get-Yfm -Text $text
        if($fm){ if($fm -match '(?m)^\s*(purpose|title)\s*:\s*(.+)$'){ $purpose = $Matches[2].Trim() } }
        if(-not $purpose){ $h1 = Get-H1 -Text $text; if($h1){ $purpose = $h1 } }
        if($text){
          foreach($m in [regex]::Matches($text,'\[[^\]]+\]\(([^)]+)\)')){
            $tgt = $m.Groups[1].Value
            if($tgt -notmatch '^(https?:|mailto:|#)'){
              $links.Add([pscustomobject]@{ from=$rel; to=$tgt })
            }
          }
        }
      }
      $role = Infer-Role $rel
      $lastDate = (git log -n 1 --format=%cs -- "$rel" 2>$null)
      $rows.Add([pscustomobject]@{
        repo  = $repoName; head = $headSha; path = $rel; ext = $ext; role = $role;
        size  = $size; sha1 = $sha1; title = $purpose; last = $lastDate
      })
    }

    # outputs
    $repoOutDir = Join-Path $gitRoot 'docs'; New-Item -ItemType Directory -Force -Path $repoOutDir | Out-Null
    $mdPath   = Join-Path $repoOutDir 'INDEX.md'
    $mmdPath  = Join-Path $repoOutDir 'INDEX_links.mmd'
    $jsonPath = Join-Path $gitRoot 'coindex.json'

    # Markdown (no tricky quoting; use -f where needed)
    $sb = New-Object System.Text.StringBuilder
    $null = $sb.AppendLine('<!-- AUTOGENERATED BY CoIndex. DO NOT EDIT. Changes will be overwritten. -->')
    $null = $sb.AppendLine(("## Repo Index — {0}" -f $repoName))
    $null = $sb.AppendLine()
    $null = $sb.AppendLine('> PURPOSE: Improve assistant-level repo awareness, enable content reuse and recursive synthesis, surface link graphs, and prevent dead ends for readers.')
    $null = $sb.AppendLine('> USAGE: Do not edit this file directly. It is auto-generated and may be overwritten on push/nightly runs. To influence rows, edit file front-matter (purpose, title, owner) or fix links in the target files.')
    $null = $sb.AppendLine(("> RUN: {0}  ·  HEAD: {1}  ·  Tool: CoCache/tools/Build-CoIndex.ps1" -f $ts,$headSha))
    $null = $sb.AppendLine()
    $null = $sb.AppendLine('| Path | Role | Title/Purpose | Last Commit | Size |')
    $null = $sb.AppendLine('|---|---|---|---:|---:|')

    foreach($r in $rows | Sort-Object path | Select-Object -First 200){
      $sz = if($r.size -lt 1KB){ ("{0} B" -f $r.size) } elseif($r.size -lt 1MB){ ("{0:n1} KB" -f ($r.size/1KB)) } else { ("{0:n1} MB" -f ($r.size/1MB)) }
      $ttl = if([string]::IsNullOrWhiteSpace($r.title)) { "" } else { $r.title }
      $null = $sb.AppendLine(("| `{0}` | {1} | {2} | {3} | {4} |" -f $r.path,$r.role,$ttl,$r.last,$sz))
    }
    if($rows.Count -gt 200){
      $null = $sb.AppendLine()
      $null = $sb.AppendLine(("> … {0} more rows in coindex.json." -f ($rows.Count-200)))
    }
    [IO.File]::WriteAllText($mdPath, $sb.ToString(), [Text.UTF8Encoding]::new($false))

    # Mermaid link graph
    $uniq = @{}; $g = New-Object System.Text.StringBuilder
    $null = $g.AppendLine('```mermaid')
    $null = $g.AppendLine('graph TD')
    foreach($e in $links | Select-Object -First 300){
      $from = ($e.from -replace '[^A-Za-z0-9_]', '_'); $to = ($e.to -replace '[^A-Za-z0-9_]', '_')
      $key = "$from->$to"; if(-not $uniq.ContainsKey($key)){ $uniq[$key]=$true; $null = $g.AppendLine(("  {0} --> {1}" -f $from,$to)) }
    }
    $null = $g.AppendLine('```')
    [IO.File]::WriteAllText($mmdPath, $g.ToString(), [Text.UTF8Encoding]::new($false))

    # JSON
    $rows | ConvertTo-Json -Depth 4 | Set-Content -Encoding UTF8 $jsonPath

    # Accumulate
    $master.AddRange($rows)

    # PR flow (optional)
    if($makePR){
      git fetch origin | Out-Null
      git switch -C $branch | Out-Null
      $filesToAdd = @("docs/INDEX.md","docs/INDEX_links.mmd","coindex.json")
      git add -- $filesToAdd
      git commit -m ("docs(index): add CoIndex (purpose+policy, table, links, JSON) [{0}]" -f $ts) 2>$null
      git push -u origin HEAD 2>$null
      if(Get-Command gh -EA SilentlyContinue){
        gh pr create --title ("docs(index): add CoIndex for {0}" -f $repoName) --body ("Autogenerated index. Run {0}." -f $ts) 2>$null | Out-Null
      }
    }
  } finally { Pop-Location }
}

# Master in CoCache
$indexDir = (Join-Path (Split-Path $PSCommandPath -Parent) "..\index")
New-Item -ItemType Directory -Force -Path $indexDir | Out-Null
$MasterOut = Join-Path $indexDir 'coindex_master.json'
$master | ConvertTo-Json -Depth 4 | Set-Content -Encoding UTF8 $MasterOut
Write-Host ("Master index: {0}" -f $MasterOut)
